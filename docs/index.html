<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Atomics.waitAsync","titleHTML":"Atomics.waitAsync","number":"","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync"},{"type":"term","term":"ClusterWaiterList","refId":"sec-semantics","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"ClusterWaiterList"},{"type":"term","term":"AsyncWaitList","refId":"sec-semantics","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"AsyncWaitList"},{"type":"op","aoid":"HostResolveInAgent","refId":"sec-hostresolveinagent","location":"","referencingIds":[],"key":"HostResolveInAgent"},{"type":"clause","id":"sec-hostresolveinagent","aoid":"HostResolveInAgent","title":"HostResolveInAgent ( W, promiseCapability, resolution)","titleHTML":"HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)","number":"1.1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_12"],"key":"HostResolveInAgent ( W, promiseCapability, resolution)"},{"type":"term","term":"ClusterWaiterList","refId":"sec-clusterwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"ClusterWaiterList"},{"type":"term","term":"alarm set","refId":"sec-clusterwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"alarm set"},{"type":"clause","id":"sec-clusterwaiterlist","aoid":null,"title":"GetClusterWaiterList ( block, i )","titleHTML":"Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )","number":"1.2","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_15","_ref_16","_ref_20","_ref_21"],"key":"GetClusterWaiterList ( block, i )"},{"type":"clause","id":"sec-alarm-functions","aoid":null,"title":"Alarm Functions","titleHTML":"Alarm Functions","number":"1.3","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_0","_ref_1"],"key":"Alarm Functions"},{"type":"op","aoid":"Suspend","refId":"sec-suspend","location":"","referencingIds":[],"key":"Suspend"},{"type":"clause","id":"sec-suspend","aoid":"Suspend","title":"Suspend ( WL, W, timeout )","titleHTML":"Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )","number":"1.4","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_27","_ref_30"],"key":"Suspend ( WL, W, timeout )"},{"type":"op","aoid":"NotifyWaiter","refId":"sec-notifywaiter","location":"","referencingIds":[],"key":"NotifyWaiter"},{"type":"clause","id":"sec-notifywaiter","aoid":"NotifyWaiter","title":"NotifyWaiter ( WL, W, value )","titleHTML":"NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>value</var></ins> )","number":"1.5","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_9","_ref_10","_ref_11","_ref_40"],"key":"NotifyWaiter ( WL, W, value )"},{"type":"op","aoid":"AddAlarm","refId":"sec-addalarm","location":"","referencingIds":[],"key":"AddAlarm"},{"type":"clause","id":"sec-addalarm","aoid":"AddAlarm","title":"AddAlarm( WL, alarmFn, timeout )","titleHTML":"AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )","number":"1.6","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_22","_ref_23","_ref_29","_ref_37"],"key":"AddAlarm( WL, alarmFn, timeout )"},{"type":"op","aoid":"CancelAlarm","refId":"sec-cancelalarm","location":"","referencingIds":[],"key":"CancelAlarm"},{"type":"clause","id":"sec-cancelalarm","aoid":"CancelAlarm","title":"CancelAlarm( WL, alarm )","titleHTML":"CancelAlarm( <var>WL</var>, <var>alarm</var> )","number":"1.7","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_13","_ref_17","_ref_31"],"key":"CancelAlarm( WL, alarm )"},{"type":"clause","id":"sec-atomics.wait","aoid":null,"title":"Atomics.wait ( typedArray, index, value, timeout )","titleHTML":"Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.8","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.wait ( typedArray, index, value, timeout )"},{"type":"clause","id":"atomics.waitasync","aoid":null,"title":"Atomics.waitAsync ( typedArray, index, value, timeout )","titleHTML":"Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.9","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync ( typedArray, index, value, timeout )"},{"type":"clause","id":"sec-atomics.notify","aoid":null,"title":"Atomics.notify ( typedArray, index, count )","titleHTML":"Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )","number":"1.10","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.notify ( typedArray, index, count )"},{"type":"clause","id":"sec-semantics","aoid":null,"title":"Semantics","titleHTML":"Semantics","number":"1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_4","_ref_5","_ref_6","_ref_8","_ref_14","_ref_19"],"key":"Semantics"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Atomics.waitAsync">Atomics.waitAsync</a></li><li><span class="item-toggle">◢</span><a href="#sec-semantics" title="Semantics"><span class="secnum">1</span> Semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-hostresolveinagent" title="HostResolveInAgent ( W, promiseCapability, resolution)"><span class="secnum">1.1</span> HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</a></li><li><span class="item-toggle-none"></span><a href="#sec-clusterwaiterlist" title="GetClusterWaiterList ( block, i )"><span class="secnum">1.2</span> Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-alarm-functions" title="Alarm Functions"><span class="secnum">1.3</span> Alarm Functions</a></li><li><span class="item-toggle-none"></span><a href="#sec-suspend" title="Suspend ( WL, W, timeout )"><span class="secnum">1.4</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-notifywaiter" title="NotifyWaiter ( WL, W, value )"><span class="secnum">1.5</span> NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>value</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-addalarm" title="AddAlarm( WL, alarmFn, timeout )"><span class="secnum">1.6</span> AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-cancelalarm" title="CancelAlarm( WL, alarm )"><span class="secnum">1.7</span> CancelAlarm( <var>WL</var>, <var>alarm</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.wait" title="Atomics.wait ( typedArray, index, value, timeout )"><span class="secnum">1.8</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#atomics.waitasync" title="Atomics.waitAsync ( typedArray, index, value, timeout )"><span class="secnum">1.9</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.notify" title="Atomics.notify ( typedArray, index, count )"><span class="secnum">1.10</span> Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / June 26, 2019</h1>
<emu-intro id="intro">
  <h1>Atomics.waitAsync</h1>
  <p>We provide a new API, <code>Atomics.waitAsync</code>, that an agent can use to wait on a shared memory location (to later be awoken by some agent calling Atomics.notify on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1><span class="secnum">1</span>Semantics</h1>
  <p>To support <code>Atomics.waitAsync</code>, the WaiterList semantic object is split into two semantic objects.</p>
  <p>A  <dfn>ClusterWaiterList</dfn> is a semantic object that contains an ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of agent signifiers of agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>. This list is agent-independent and, like the current WaiterList semantic object, is shared by all agents in an agent cluster.</p>
  <p>An  <dfn>AsyncWaitList</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Records that have a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> and an alarm id. Each <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> encapsulates the result of a call to <code>Atomics.waitAsync</code>, and <emu-val>null</emu-val> denotes a call to <code>Atomics.wait</code>. This list is per-agent.</p>
  <p>Additionally, Agent Records tracks whether the agent is currently blocked.</p>
  <p>Conceptually, agents that call either <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> are appended to ClusterWaiterList. If the call was to <code>Atomics.wait</code>, the agent is marked as blocked. If the call was to <code>Atomics.waitAsync</code>, the result PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> is appended to that agent's AsyncWaitList.</p>
  <p>This enables two design goals:</p>
  <ol>
    <li>Waiting agents are notified in FIFO order for fairness.</li>
    <li>Asynchronous waits in one agent are notified in FIFO order, while synchronous waits are notified before any asynchronous wait. This is because resolving the Promise result of a call to <code>Atomics.waitAsync</code> does no meaningful computation if the agent is in a blocking wait.</li>
  </ol>

  <p>Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> is modified as follows.</p>
  <emu-table caption="Agent Record Fields"><figure><figcaption>Table 1: Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> Fields</figcaption>
    <table>
      <tbody>
        <tr>
          <th>Field Name</th>
          <th>Value</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>Boolean</td>
          <td>The default value computed for the  <em>isLittleEndian</em> parameter when it is needed by the algorithms <emu-xref aoid="GetValueFromBuffer" id="_ref_2"><a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer" id="_ref_3"><a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>. The choice is implementation-dependent and should be the alternative that is most efficient for the implementation.  Once the value has been observed it cannot change.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>Boolean</td>
          <td>Determines whether the agent can block or not.</td>
        </tr>
        <tr>
          <td><ins>[[Blocked]]</ins></td>
          <td><ins>Boolean</ins></td>
          <td><ins>Determines if the agent is blocked by <code>Atomics.wait</code>. If [[CanBlock]] is <emu-val>false</emu-val>, this value is always <emu-val>false</emu-val>.</ins></td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>Any globally-unique value</td>
          <td>Uniquely identifies the agent within its agent cluster.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>Boolean</td>
          <td><emu-val>true</emu-val> if atomic operations on one-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>Boolean</td>
          <td><emu-val>true</emu-val> if atomic operations on two-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>A candidate execution <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref></td>
          <td>See the memory model.</td>
        </tr>
      </tbody>
      <tbody><tr>
        <td><ins>[[AsyncWaitList]]</ins></td>
        <td><ins>An AsyncWaitList</ins></td>
        <td><ins>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Records denoting calls to <code>Atomics.waitAsync</code>.</ins></td>
      </tr>
    </tbody></table>
  </figure></emu-table>

  <emu-clause id="sec-hostresolveinagent" aoid="HostResolveInAgent">
    <h1><span class="secnum">1.1</span>HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</h1>
    <p><ins>This is a new section.</ins></p>
    <p>HostResolveInAgent is an implementation-defined abstract operation that takes three arguments, an agent signifier <var>W</var>, a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>promiseCapability</var>, and a value <var>resolution</var>. The host's responsibility is to resolve the <var>promiseCapability</var> in the agent signified by <var>W</var> with <var>resolution</var> in finite time. The host may delay resolving the <var>promiseCapability</var> in <var>W</var>, e.g. for resource management reasons, but the promise must eventually be resolved.</p>
  </emu-clause>

  <emu-clause id="sec-clusterwaiterlist">
    <h1><span class="secnum">1.2</span>Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )</h1>
    <p>A  <dfn><ins>Cluster</ins>WaiterList</dfn> is a semantic object that contains an ordered list of agent signifiers of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>.</p>
    <p><ins>There can be multiple entries in a <emu-xref href="#sec-semantics" id="_ref_4"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> with the same agent signifier.</ins></p>
    <p><ins>The <emu-xref href="#sec-semantics" id="_ref_5"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> has an attached  <dfn>alarm set</dfn>, a set of truthy values. This set is manipulated only when the agent manipulating it is in the critical section for the <emu-xref href="#sec-semantics" id="_ref_6"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref>.</ins></p>
    <p>The agent cluster has a store of  <ins>Cluster</ins>WaiterList objects; the store is indexed by (<var>block</var>, <var>i</var>). WaiterLists are agent-independent: a lookup in the store of  <ins>Cluster</ins>WaiterLists by (<var>block</var>, <var>i</var>) will result in the same  <ins>Cluster</ins>WaiterList object in any agent in the agent cluster.</p>
    <p>Operations on a  <ins>Cluster</ins>WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, adding and removing alarms -- may only be performed by agents that have entered the  <ins>Cluster</ins>WaiterList's critical section.</p>
    <p>The abstract operation <emu-xref aoid="Get" id="_ref_7"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList takes two arguments, a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> and a nonnegative integer <var>i</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var> + 3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <ins>Cluster</ins>WaiterList that is referenced by the pair (<var>block</var>, <var>i</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-alarm-functions">
    <h1><span class="secnum">1.3</span>Alarm Functions</h1>
    <p><ins>This is a new section.</ins></p>
    <p>An alarm function is an anonymous built-in function that has [[WaiterList]], [[Waiter]], [[Kind]], and [[Result]] internal slots.</p>
    <p>When an alarm function is called with no arguments, the following steps are taken:</p>
    <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href="#active-function-object"><a href="https://tc39.github.io/ecma262/#active-function-object">active function object</a></emu-xref>.</li><li>Assert: <var>F</var> has a [[WaiterList]] internal slot whose value is a <emu-xref href="#sec-semantics" id="_ref_8"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref>.</li><li>Assert: <var>F</var> has a [[Waiter]] internal slot whose value is an agent signifier.</li><li>Assert: <var>F</var> has a [[Kind]] internal slot whose value is a String.</li><li>Let <var>WL</var> be <var>F</var>.[[WaiterList]].</li><li>Let <var>W</var> be <var>F</var>.[[Waiter]].</li><li>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</li><li>If <var>F</var>.[[Kind]] is <code>"sync"</code>, then<ol><li>Set <var>F</var>.[[Result]].[[Value]] to the String <code>"timed-out"</code>.</li></ol></li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Perform RemoveWaiter(<var>WL</var>, <var>W</var>).</li><li>If <var>F</var>.[[Result]] is <code>"async"</code>, then<ol><li>Let <var>asyncRecord</var> be <var>F</var>.[[Result]].</li><li>Assert: <var>asyncRecord</var> is in <var>AR</var>.[[AsyncWaitList]].</li><li>Remove <var>asyncRecord</var> from <var>AR</var>.[[AsyncWaitList]].</li></ol></li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_9"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>asyncRecord</var>, <code>"timed-out"</code>).</li><li>Perform LeaveCriticalSection(<var>WL</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a <var>timeout</var> argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1><span class="secnum">1.4</span>Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</h1>
    <p>The abstract operation Suspend takes  <del>three</del><ins>two</ins> arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var><del>,</del><ins>and</ins> an agent signifier <var>W</var><del>, and a nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var></del>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to AgentSignifier().</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Assert: AgentCanSuspend() is <emu-val>true</emu-val>.</li><li>Perform LeaveCriticalSection(<var>WL</var>) and suspend <var>W</var> for up to <var>timeout</var> milliseconds, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_10"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, ...), and not for any other reasons at all.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li><ins>Set the [[Blocked]] field of Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var> to <emu-val>true</emu-val>.</ins></li><li><del>If <var>W</var> was notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_11"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), return <emu-val>true</emu-val>.</del></li><li><del>Return <emu-val>false</emu-val>.</del>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1><span class="secnum">1.5</span>NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>value</var></ins> )</h1>
    <p>The abstract operation NotifyWaiter takes  <del>two</del><ins>three</ins> arguments,
      a  <ins>Cluster</ins>WaiterList <var>WL</var>  <del>and</del><ins>,</ins> an agent signifier <var>W</var><ins>, and a String <var>value</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li><ins>Assert: <var>value</var> is either the String <code>"ok"</code> or the String <code>"timed-out"</code>.</ins></li><li><ins>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</ins></li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the surrounding agent's Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the Agent Events <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().</li><li>Let <var>agentSynchronizesWith</var> be <var>eventsRecord</var>.[[AgentSynchronizesWith]].</li><li>Let <var>notifierEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>waiterEventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <var>W</var>.</li><li>Let <var>notifyEvent</var> and <var>waitEvent</var> be new Synchronize events.</li><li>Append <var>notifyEvent</var> to <var>notifierEventList</var>.</li><li>Append <var>waitEvent</var> to <var>waiterEventList</var>.</li><li>Append (<var>notifyEvent</var>, <var>waitEvent</var>) to <var>agentSynchronizesWith</var>.</li><li><del>Notify the agent <var>W</var>.</del><ins>If <var>AR</var>.[[Blocked]] is <emu-val>true</emu-val>, then</ins><ol><li><ins>Set <var>AR</var>.[[Blocked]] to <emu-val>false</emu-val>.</ins></li><li><ins>Notify the agent <var>W</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Assert: <var>AR</var>.[[AsyncWaitList]] is not an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</ins></li><li><ins>Let <var>asyncRecord</var> be the first element of <var>AR</var>.[[AsyncWaitList]].</ins></li><li><ins>Remove the first element of <var>AR</var>.[[AsyncWaitList]].</ins></li><li><ins>Perform <emu-xref aoid="HostResolveInAgent" id="_ref_12"><a href="#sec-hostresolveinagent">HostResolveInAgent</a></emu-xref>(<var>W</var>, <var>asyncRecord</var>.[[PromiseCapability]], <var>value</var>)</ins></li><li><ins>NOTE: An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</ins></li><li><ins>If <var>asyncRecord</var>.[[Alarm]] is truthy, then</ins><ol><li><ins>Perform <emu-xref aoid="CancelAlarm" id="_ref_13"><a href="#sec-cancelalarm">CancelAlarm</a></emu-xref>(<var>WL</var>, <var>asyncRecord</var>.[[Alarm]]).</ins>
    </li></ol></li></ol></li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>The embedding may delay notifying <var>W</var>, e.g. for resource management reasons, but <var>W</var> must eventually be notified in order to guarantee forward progress.</p>
    </div></emu-note>
  </emu-clause>

  <emu-clause id="sec-addalarm" aoid="AddAlarm">
    <h1><span class="secnum">1.6</span>AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation AddAlarm takes three arguments, a <emu-xref href="#sec-semantics" id="_ref_14"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> <var>WL</var>, a thunk <var>alarmFn</var>, and a nonnegative finite number <var>timeout</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>alarm</var> be a truthy value that is not in <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_15"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>Add <var>alarm</var> to <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_16"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>After <var>timeout</var> milliseconds has passed, perform the following actions concurrently:<ol><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>If <emu-xref aoid="CancelAlarm" id="_ref_17"><a href="#sec-cancelalarm">CancelAlarm</a></emu-xref>(<var>WL</var>, <var>alarm</var>) is <emu-val>true</emu-val>, then<ol><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_18"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>alarmFn</var>, <emu-val>undefined</emu-val>, « »).</li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>NOTE: <var>alarmFn</var> is now dead.</li></ol></li><li>Return <var>alarm</var>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-cancelalarm" aoid="CancelAlarm">
    <h1><span class="secnum">1.7</span>CancelAlarm( <var>WL</var>, <var>alarm</var> )</h1>
    <p><ins>This is a new abstraction operation.</ins></p>
    <p>The abstract operation CancelAlarm takes two arguments, a <emu-xref href="#sec-semantics" id="_ref_19"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> <var>WL</var>, and a truthy value <var>alarm</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>alarm</var> is a truthy value.</li><li>If <var>alarm</var> is in <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_20"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>, then<ol><li>Remove <var>alarm</var> from <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_21"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>Return <emu-val>true</emu-val>.</li><li>NOTE: No alarm that subsequently triggers for <var>alarm</var> (in the concurrent thread referenced in <emu-xref aoid="AddAlarm" id="_ref_22"><a href="#sec-addalarm">AddAlarm</a></emu-xref>) will have any effect. If not called from <emu-xref aoid="AddAlarm" id="_ref_23"><a href="#sec-addalarm">AddAlarm</a></emu-xref>, the thunk associated with <var>alarm</var> is now dead and can be reclaimed; any scheduled timeout associated with alarm can be canceled.</li></ol></li><li>Else return <emu-val>false</emu-val>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1><span class="secnum">1.8</span>Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.wait</code> puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_24"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_25"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="Get" id="_ref_26"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return the String <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li><del>Perform AddWaiter(<var>WL</var>, <var>W</var>).</del></li><li><del>Let <var>notified</var> be <emu-xref aoid="Suspend" id="_ref_27"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, then</del><ol><li><del>Assert: <var>W</var> is not on the list of waiters in <var>WL</var>.</del></li></ol></li><li><del>Else,</del><ol><li><del>Perform RemoveWaiter(<var>WL</var>, <var>W</var>).</del></li></ol></li><li><ins>Let <var>syncResult</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[Value]]: <code>"ok"</code> }.</ins></li><li><ins>Let <var>alarm</var> be <emu-val>false</emu-val>.</ins></li><li><ins>If <var>t</var> is finite, then</ins><ol><li><ins>Let <var>stepsAlarm</var> be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions" id="_ref_0"><a href="#sec-alarm-functions">1.3</a></emu-xref>).</ins></li><li><ins>Let <var>alarmFn</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_28"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(<var>stepsAlarm</var>, « [[WaiterList]], [[Waiter]], [[Kind]], [[Result]] »).</ins></li><li><ins>Set <var>alarmFn</var>.[[WaiterList]] to <var>WL</var>.</ins></li><li><ins>Set <var>alarmFn</var>.[[Waiter]] to <var>W</var>.</ins></li><li><ins>Set <var>alarmFn</var>.[[Kind]] to the String <code>"sync"</code>.</ins></li><li><ins>Set <var>alarmFn</var>.[[Result]] to <var>syncResult</var>.</ins></li><li><ins>Set <var>alarm</var> to <emu-xref aoid="AddAlarm" id="_ref_29"><a href="#sec-addalarm">AddAlarm</a></emu-xref>(<var>WL</var>, <var>alarmFn</var>, <var>t</var>).</ins></li></ol></li><li><ins>Perform AddWaiter(<var>WL</var>, <var>W</var>).</ins></li><li><ins>Perform <emu-xref aoid="Suspend" id="_ref_30"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</ins></li><li><ins>If <var>syncResult</var>.[[Value]] is <code>"ok"</code> and <var>alarm</var> is a truthy value, then</ins><ol><li><ins>Perform <emu-xref aoid="CancelAlarm" id="_ref_31"><a href="#sec-cancelalarm">CancelAlarm</a></emu-xref>(<var>WL</var>, <var>alarm</var>).</ins></li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, return the String <code>"ok"</code>.</del></li><li>Return <del>the String <code>"timed-out"</code></del><ins><var>syncResult</var>.[[Value]]<!-- ns-->.
    </ins></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="atomics.waitasync">
    <h1><span class="secnum">1.9</span>Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new method.</ins></p>
    <p><code>Atomics.waitAsync</code> returns a Promise that is resolved when the calling agent is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_33"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetClusterWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_34"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_35"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>capability</var>.[[Resolve]], <emu-val>undefined</emu-val>, « <code>"not-equal"</code> »).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</li><li>Let <var>alarm</var> be <emu-val>false</emu-val>.</li><li>Let <var>asyncRecord</var> be { [[PromiseCapability]]: <var>promiseCapability</var>, [[Alarm]]: <var>alarm</var> }.</li><li>Let <var>t</var> is finite, then<ol><li>Let <var>stepsAlarm</var> be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions" id="_ref_1"><a href="#sec-alarm-functions">1.3</a></emu-xref>).</li><li>Let <var>alarmFn</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_36"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(<var>stepsAlarm</var>, « [[WaiterList]], [[Waiter]], [[Kind]], [[Result]] »).</li><li>Set <var>alarmFn</var>.[[WaiterList]] to <var>WL</var>.</li><li>Set <var>alarmFn</var>.[[Waiter]] to <var>W</var>.</li><li>Set <var>alarmFn</var>.[[Kind]] to the String <code>"async"</code>.</li><li>Set <var>alarmFn</var>.[[Result]] to <var>asyncRecord</var>.</li><li>Set <var>alarm</var> to <emu-xref aoid="AddAlarm" id="_ref_37"><a href="#sec-addalarm">AddAlarm</a></emu-xref>(<var>WL</var>, <var>alarmFn</var>, <var>t</var>).</li><li>Set <var>asyncRecord</var>.[[Alarm]] to <var>alarm</var>.</li></ol></li><li>Perform AddWaiter(<var>WL</var>, <var>W</var>).</li><li>Append <var>asyncRecord</var> as the last element of the <var>AR</var>.[[AsyncWaitList]].</li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.notify">
    <h1><span class="secnum">1.10</span>Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )</h1>
    <p><code>Atomics.notify</code> notifies some agents that are sleeping in the wait queue.  The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>If <var>count</var> is <emu-val>undefined</emu-val>, let <var>c</var> be <emu-val>+∞</emu-val>.</li><li>Else,<ol><li>Let <var>intCount</var> be ?&nbsp;<emu-xref aoid="ToInteger" id="_ref_38"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>count</var>).</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>intCount</var>, 0).</li></ol></li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="Get" id="_ref_39"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>n</var> be 0.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>S</var> be RemoveWaiters(<var>WL</var>, <var>c</var>).</li><li>Repeat, while <var>S</var> is not an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>,<ol><li>Let <var>W</var> be the first agent in <var>S</var>.</li><li>Remove <var>W</var> from the front of <var>S</var>.</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_40"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var><ins>, <code>"ok"</code></ins>).</li><li>Add 1 to <var>n</var>.</li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return <var>n</var>.
    </li></ol></emu-alg>
  </emu-clause>

</emu-clause>
</div></body>