<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Atomics.waitAsync","titleHTML":"Atomics.waitAsync","number":"","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync"},{"type":"op","aoid":"HostResolveInAgent","refId":"sec-hostresolveinagent","location":"","referencingIds":[],"key":"HostResolveInAgent"},{"type":"clause","id":"sec-hostresolveinagent","aoid":"HostResolveInAgent","title":"HostResolveInAgent ( W, promiseCapability, resolution)","titleHTML":"HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)","number":"1.1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_31"],"key":"HostResolveInAgent ( W, promiseCapability, resolution)"},{"type":"term","term":"Waiter Record","refId":"sec-getwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Waiter Record"},{"type":"table","id":"table-waiterrecord","number":1,"caption":"Table 1: Waiter Record Fields","referencingIds":["_ref_0"],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Table 1: Waiter Record Fields"},{"type":"term","term":"WaiterList","refId":"sec-getwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"WaiterList"},{"type":"table","id":"table-waiterlist","number":2,"caption":"Table 2: WaiterList Record Fields","referencingIds":["_ref_1"],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"Table 2: WaiterList Record Fields"},{"type":"clause","id":"sec-getwaiterlist","aoid":null,"title":"GetWaiterList ( block, i )","titleHTML":"GetWaiterList ( <var>block</var>, <var>i</var> )","number":"1.2","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_2","_ref_3","_ref_4","_ref_5","_ref_6","_ref_7","_ref_9","_ref_10","_ref_11","_ref_16","_ref_17","_ref_18","_ref_19","_ref_21","_ref_22","_ref_23","_ref_24","_ref_29","_ref_30","_ref_38","_ref_49"],"key":"GetWaiterList ( block, i )"},{"type":"op","aoid":"EnterCriticalSection","refId":"sec-entercriticalsection","location":"","referencingIds":[],"key":"EnterCriticalSection"},{"type":"clause","id":"sec-entercriticalsection","aoid":"EnterCriticalSection","title":"EnterCriticalSection ( WL )","titleHTML":"EnterCriticalSection ( <var>WL</var> )","number":"1.3","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_12","_ref_27","_ref_35","_ref_44"],"key":"EnterCriticalSection ( WL )"},{"type":"op","aoid":"LeaveCriticalSection","refId":"sec-leavecriticalsection","location":"","referencingIds":[],"key":"LeaveCriticalSection"},{"type":"clause","id":"sec-leavecriticalsection","aoid":"LeaveCriticalSection","title":"LeaveCriticalSection ( WL )","titleHTML":"LeaveCriticalSection ( <var>WL</var> )","number":"1.4","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_8","_ref_15","_ref_25","_ref_36","_ref_41","_ref_45","_ref_52"],"key":"LeaveCriticalSection ( WL )"},{"type":"op","aoid":"TriggerTimeout","refId":"sec-triggertimeout","location":"","referencingIds":[],"key":"TriggerTimeout"},{"type":"clause","id":"sec-triggertimeout","aoid":"TriggerTimeout","title":"TriggerTimeout( WL, waiterRecord )","titleHTML":"TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )","number":"1.5","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_20"],"key":"TriggerTimeout( WL, waiterRecord )"},{"type":"op","aoid":"AddWaiter","refId":"sec-addwaiter","location":"","referencingIds":[],"key":"AddWaiter"},{"type":"clause","id":"sec-addwaiter","aoid":"AddWaiter","title":"AddWaiter ( WL,  WwaiterRecord )","titleHTML":"AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.6","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_39","_ref_46","_ref_50"],"key":"AddWaiter ( WL,  WwaiterRecord )"},{"type":"op","aoid":"RemoveWaiter","refId":"sec-removewaiter","location":"","referencingIds":[],"key":"RemoveWaiter"},{"type":"clause","id":"sec-removewaiter","aoid":"RemoveWaiter","title":"RemoveWaiter ( WL,  WwaiterRecord )","titleHTML":"RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.7","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_13","_ref_48"],"key":"RemoveWaiter ( WL,  WwaiterRecord )"},{"type":"op","aoid":"Suspend","refId":"sec-suspend","location":"","referencingIds":[],"key":"Suspend"},{"type":"clause","id":"sec-suspend","aoid":"Suspend","title":"Suspend ( WL, W, timeout )","titleHTML":"Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )","number":"1.8","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_40","_ref_47","_ref_51"],"key":"Suspend ( WL, W, timeout )"},{"type":"op","aoid":"NotifyWaiter","refId":"sec-notifywaiter","location":"","referencingIds":[],"key":"NotifyWaiter"},{"type":"clause","id":"sec-notifywaiter","aoid":"NotifyWaiter","title":"NotifyWaiter ( WL,  WwaiterRecord )","titleHTML":"NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.9","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_14","_ref_26","_ref_28"],"key":"NotifyWaiter ( WL,  WwaiterRecord )"},{"type":"op","aoid":"DoWait","refId":"sec-dowait","location":"","referencingIds":[],"key":"DoWait"},{"type":"clause","id":"sec-dowait","aoid":"DoWait","title":"DoWait ( mode, typedArray, index, value, timeout )","titleHTML":"DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.10","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_53"],"key":"DoWait ( mode, typedArray, index, value, timeout )"},{"type":"clause","id":"sec-atomics.wait","aoid":null,"title":"Atomics.wait ( typedArray, index, value, timeout )","titleHTML":"Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.11","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.wait ( typedArray, index, value, timeout )"},{"type":"clause","id":"atomics.waitasync","aoid":null,"title":"Atomics.waitAsync ( typedArray, index, value, timeout )","titleHTML":"Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.12","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync ( typedArray, index, value, timeout )"},{"type":"clause","id":"sec-semantics","aoid":null,"title":"Semantics","titleHTML":"Semantics","number":"1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Semantics"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Atomics.waitAsync">Atomics.waitAsync</a></li><li><span class="item-toggle">◢</span><a href="#sec-semantics" title="Semantics"><span class="secnum">1</span> Semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-hostresolveinagent" title="HostResolveInAgent ( W, promiseCapability, resolution)"><span class="secnum">1.1</span> HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</a></li><li><span class="item-toggle-none"></span><a href="#sec-getwaiterlist" title="GetWaiterList ( block, i )"><span class="secnum">1.2</span> GetWaiterList ( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-entercriticalsection" title="EnterCriticalSection ( WL )"><span class="secnum">1.3</span> EnterCriticalSection ( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-leavecriticalsection" title="LeaveCriticalSection ( WL )"><span class="secnum">1.4</span> LeaveCriticalSection ( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-triggertimeout" title="TriggerTimeout( WL, waiterRecord )"><span class="secnum">1.5</span> TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-addwaiter" title="AddWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.6</span> AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-removewaiter" title="RemoveWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.7</span> RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-suspend" title="Suspend ( WL, W, timeout )"><span class="secnum">1.8</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-notifywaiter" title="NotifyWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.9</span> NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-dowait" title="DoWait ( mode, typedArray, index, value, timeout )"><span class="secnum">1.10</span> DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.wait" title="Atomics.wait ( typedArray, index, value, timeout )"><span class="secnum">1.11</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#atomics.waitasync" title="Atomics.waitAsync ( typedArray, index, value, timeout )"><span class="secnum">1.12</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / September 28, 2019</h1>
<emu-intro id="intro">
  <h1>Atomics.waitAsync</h1>
  <p>We provide a new API, <code>Atomics.waitAsync</code>, that an agent can use to wait on a shared memory location (to later be awoken by some agent calling Atomics.notify on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1><span class="secnum">1</span>Semantics</h1>

  <emu-clause id="sec-hostresolveinagent" aoid="HostResolveInAgent">
    <h1><span class="secnum">1.1</span>HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</h1>
    <p><ins>This is a new section.</ins></p>
    <p>HostResolveInAgent is an implementation-defined abstract operation that takes three arguments, an agent signifier <var>W</var>, a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>promiseCapability</var>, and a value <var>resolution</var>. The host's responsibility is to resolve the <var>promiseCapability</var> in the agent signified by <var>W</var> with <var>resolution</var> in finite time. The host may delay resolving the <var>promiseCapability</var> in <var>W</var>, e.g. for resource management reasons, but the promise must eventually be resolved.</p>
  </emu-clause>

  <emu-clause id="sec-getwaiterlist">
    <h1><span class="secnum">1.2</span>GetWaiterList ( <var>block</var>, <var>i</var> )</h1>
    <p><ins>A  <dfn>Waiter Record</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> value used to denote a particular call to <code>Atomics.wait</code> or <code>Atomics.waitAsync</code>. It has fields as defined by  <emu-xref href="#table-waiterrecord" id="_ref_0"><a href="#table-waiterrecord">Table 1</a></emu-xref>.</ins></p>
    <emu-table id="table-waiterrecord" caption="Waiter Record Fields"><figure><figcaption>Table 1: <emu-xref href="#sec-getwaiterlist" id="_ref_2"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
              Field Name
            
            </th>
            <th>
              Value
            
            </th>
            <th>
              Meaning
            
            </th>
          </tr>
          <tr>
            <td>
              [[AgentSignifier]]
            
            </td>
            <td>
              An agent signifier
            
            </td>
            <td>
              The agent that called <code>Atomics.wait</code> or <code>Atomics.waitAsync</code>.
            
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            
            </td>
            <td>
              A PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> or <emu-val>undefined</emu-val>
            
            </td>
            <td>
              If denoting a call to <code>Atomics.waitAsync</code>, the resulting promise, otherwise <emu-val>undefined</emu-val>.
            
            </td>
          </tr>
          <tr>
            <td>
              [[Timeout]]
            
            </td>
            <td>
              A non-negative Number
            
            </td>
            <td>
              The timeout in milliseconds.
            
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            
            </td>
            <td>
              <code>"ok"</code> or <code>"timed-out"</code>
            
            </td>
            <td>
              The return value of the call.
            
            </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>
    <p>A  <dfn>WaiterList</dfn> is a  <del>semantic object that contains an ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>. A WaiterList object also optionally contains a Synchronize event denoting the previous leaving of its critical section.</del><ins><emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> value used to explain waiting and notification of agents via <code>Atomics.wait</code>, <code>Atomics.waitAsync</code>, and <code>Atomics.notify</code>. It has fields as defined by  <emu-xref href="#table-waiterlist" id="_ref_1"><a href="#table-waiterlist">Table 2</a></emu-xref>.</ins></p>
    <emu-table id="table-waiterlist" caption="WaiterList Record Fields"><figure><figcaption>Table 2: <emu-xref href="#sec-getwaiterlist" id="_ref_3"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>
              Field Name
            
            </th>
            <th>
              Value
            
            </th>
            <th>
              Meaning
            
            </th>
          </tr>
          <tr>
            <td>
              [[Waiters]]
            
            </td>
            <td>
              An ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Waiter Records
            
            </td>
            <td>
              The calls to <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> that are waiting on the location with which this <emu-xref href="#sec-getwaiterlist" id="_ref_4"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> is associated.
            
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            
            </td>
            <td>
              A Synchronize event or <emu-val>undefined</emu-val>
            
            </td>
            <td>
              The event of the most recent leaving of its critical section, or <emu-val>undefined</emu-val> if its critical section has never been entered.
            
            </td>
          </tr>
        </tbody>
      </table>
    </figure></emu-table>
    <p><ins>There can be multiple Waiter Records in a WaiterList with the same agent signifier.</ins></p>
    <p>The agent cluster has a store of WaiterList  <del>objects</del><ins>Records</ins>; the store is indexed by (<var>block</var>, <var>i</var>)<ins>, where <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var></ins>. WaiterLists are agent-independent: a lookup in the store of WaiterLists by (<var>block</var>, <var>i</var>) will result in the same WaiterList object in any agent in the agent cluster.</p>
    <p>Operations on a WaiterList—adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, setting and retrieving the Synchronize event—may only be performed by agents that have entered the WaiterList's critical section.</p>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>Conceptually, agents that call either <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> are appended to WaiterList. If the call was to <code>Atomics.wait</code> in an agent A, a Waiter Record with an <emu-val>undefined</emu-val> [[PromiseCapability]] is inserted to be immediately preceding the first element whose [[AgentSignifier]] is A. If the call was to <code>Atomics.waitAsync</code>, a WaiterRecord whose [[PromiseCapability]] is the resulting PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> is appended.</p>
      <p>This enables two design goals:</p>
      <ol>
        <li>Waiting agents are notified in FIFO order for fairness.</li>
        <li>Asynchronous waits in one agent are notified in FIFO order, while synchronous waits are notified before any asynchronous wait. This is because resolving the Promise result of a call to <code>Atomics.waitAsync</code> does no meaningful computation if the agent is in a blocking wait.</li>
      </ol>
    </div></emu-note>
    <p>The abstract operation GetWaiterList takes two arguments, a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> and a nonnegative integer <var>i</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var> + 3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <emu-xref href="#sec-getwaiterlist" id="_ref_5"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> that is referenced by the pair (<var>block</var>, <var>i</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-entercriticalsection" aoid="EnterCriticalSection">
    <h1><span class="secnum">1.3</span>EnterCriticalSection ( <var>WL</var> )</h1>
    <p>The abstract operation EnterCriticalSection takes one argument, a <emu-xref href="#sec-getwaiterlist" id="_ref_6"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is not in the critical section for any <emu-xref href="#sec-getwaiterlist" id="_ref_7"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref>.</li><li>Wait until no agent is in the critical section for <var>WL</var>, then enter the critical section for <var>WL</var> (without allowing any other agent to enter).</li><li>If <var>WL</var><del> has a Synchronize event</del><ins>.[[MostRecentLeaveEvent]] is <emu-val>undefined</emu-val></ins>, then</li><li>NOTE: A <var>WL</var> whose critical section has been entered at least once has a Synchronize event set by <emu-xref aoid="LeaveCriticalSection" id="_ref_8"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the surrounding agent's Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the Agent Events <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().</li><li>Let <var>entererEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>enterEvent</var> be a new Synchronize event.</li><li>Append <var>enterEvent</var> to <var>entererEventList</var>.</li><li>Let <var>leaveEvent</var> be the Synchronize event in <var>WL</var>.</li><li>Append (<var>leaveEvent</var>, <var>enterEvent</var>) to <var>eventRecords</var>.[[AgentSynchronizesWith]].
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-leavecriticalsection" aoid="LeaveCriticalSection">
    <h1><span class="secnum">1.4</span>LeaveCriticalSection ( <var>WL</var> )</h1>
    <p>The abstract operation LeaveCriticalSection takes one argument, a <emu-xref href="#sec-getwaiterlist" id="_ref_9"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the calling surrounding's Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the Agent Events <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().</li><li>Let <var>leaverEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>leaveEvent</var> be a new Synchronize event.</li><li>Append <var>leaveEvent</var> to <var>leaverEventList</var>.</li><li>Set <del>the Synchronize event in <var>WL</var> to <var>leaveEvent</var></del><ins><var>WL</var>.[[MostRecentLeaveEvent]] to <var>leaveEvent</var></ins>.</li><li>Leave the critical section for <var>WL</var>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-triggertimeout" aoid="TriggerTimeout">
    <h1><span class="secnum">1.5</span>TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation TriggerTimeout takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_10"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and a <emu-xref href="#sec-getwaiterlist" id="_ref_11"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> <var>waiterRecord</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>waiterRecord</var>.[[Timeout]] is finite.</li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_12"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>waiterRecord</var> is in <var>WL</var>.[[Waiters]], then<ol><li>Set <var>waiterRecord</var>.[[Result]] to <code>"timed-out"</code>.</li><li>Perform <emu-xref aoid="RemoveWaiter" id="_ref_13"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_14"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_15"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-addwaiter" aoid="AddWaiter">
    <h1><span class="secnum">1.6</span>AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation AddWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_16"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-getwaiterlist" id="_ref_17"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><del>Assert: <var>W</var> is not on the list of waiters in any <emu-xref href="#sec-getwaiterlist" id="_ref_18"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref>.</del></li><li><ins>Let <var>inserted</var> be <emu-val>false</emu-val>.</ins></li><li><ins>If <var>waiterRecord</var>.[[PromiseCapability]] is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Assert: There is no <emu-xref href="#sec-getwaiterlist" id="_ref_19"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> in <var>WL</var>.[[Waiters]] whose [[AgentSignifier]] field is <var>waiterRecord</var>.[[AgentSignifier]].</ins></li><li><ins>For each element <var>wr</var> in <var>WL</var>.[[Waiters]], do</ins><ol><li><ins>If <var>wr</var>.[[AgentSignifier]] is <var>waiterRecord</var>.[[AgentSignifier]], then</ins><ol><li><ins>Insert <var>waiterRecord</var> to immediately precede <var>wr</var> in <var>WL</var>.[[Waiters]].</ins></li><li><ins>Set <var>inserted</var> to <emu-val>true</emu-val>.</ins></li></ol></li></ol></li></ol></li><li><ins>If <var>inserted</var> is <emu-val>false</emu-val>, then</ins><ol><li><ins>Append <var>waiterRecord</var> as the last element of <var>WL</var>.[[Waiters]]</ins></li></ol></li><li><ins>If <var>waiterRecord</var>.[[Timeout]] is finite, then in parallel,</ins><ol><li><ins>Wait <var>waiterRecord</var>.[[Timeout]] milliseconds.</ins></li><li><ins>Perform <emu-xref aoid="TriggerTimeout" id="_ref_20"><a href="#sec-triggertimeout">TriggerTimeout</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</ins>
    </li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
    <h1><span class="secnum">1.7</span>RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation RemoveWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_21"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-getwaiterlist" id="_ref_22"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <del><var>W</var></del><ins><var>waiterRecord</var></ins> is <del>on the list of waiters</del> in <var>WL</var><ins>.[[Waiters]]</ins>.</li><li>Remove <del><var>W</var></del><ins><var>waiterRecord</var></ins> from <del>the list of waiters in</del> <var>WL</var><ins>.[[Waiters]]</ins>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a <var>timeout</var> argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1><span class="secnum">1.8</span>Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</h1>
    <p>The abstract operation Suspend takes  <del>three</del><ins>two</ins> arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_23"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var><del>,</del><ins>and</ins> an agent signifier <var>W</var><del>, and a nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var></del>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to AgentSignifier().</li><li>Assert: <del><var>W</var> is on the list of waiters.</del><ins>There is a <emu-xref href="#sec-getwaiterlist" id="_ref_24"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref></ins> in <var>WL</var><ins>.[[Waiters]] whose [[AgentSignifier]] field is <var>W</var> and whose [[PromiseCapability]] field is <emu-val>undefined</emu-val>.</ins></li><li>Assert: AgentCanSuspend() is <emu-val>true</emu-val>.</li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_25"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>) and suspend <var>W</var><del> for up to <var>timeout</var> milliseconds</del>, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_26"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>, ...), and not for any other reasons at all.</li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_27"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li><del>If <var>W</var> was notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_28"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), return <emu-val>true</emu-val>.</del></li><li><del>Return <emu-val>false</emu-val>.</del>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1><span class="secnum">1.9</span>NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation NotifyWaiter takes two arguments,
      a <emu-xref href="#sec-getwaiterlist" id="_ref_29"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-getwaiterlist" id="_ref_30"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><del>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</del></li><li><ins>Assert: <var>waiterRecord</var>.[[Result]] is either the String <code>"ok"</code> or the String <code>"timed-out"</code>.</ins></li><li><del>Notify the agent <var>W</var>.</del></li><li><ins>If <var>waiterRecord</var>.[[PromiseCapability]] is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>NOTE: An <emu-val>undefined</emu-val> promise capability denotes a blocking wait.</ins></li><li><ins>Notify the agent <var>waiterRecord</var>.[[AgentSignifier]].</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Perform <emu-xref aoid="HostResolveInAgent" id="_ref_31"><a href="#sec-hostresolveinagent">HostResolveInAgent</a></emu-xref>(<var>W</var>, <var>waiterRecord</var>.[[PromiseCapability]], <var>waiterRecord</var>.[[Result]])</ins></li><li><ins>NOTE: An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</ins>
    </li></ol></li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>The embedding may delay notifying  <del><var>W</var></del><ins>the agent whose signifier is <var>waiter</var>.[[AgentSignifier]]</ins>, e.g. for resource management reasons, but  <del><var>W</var></del><ins>that agent</ins> must eventually be notified in order to guarantee forward progress.</p>
    </div></emu-note>
  </emu-clause>

  <emu-clause id="sec-dowait" aoid="DoWait">
    <h1><span class="secnum">1.10</span>DoWait ( <var>mode</var>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation DoWait takes five arguments, a String <var>mode</var>, and values <var>typedArray</var>, <var>idnex</var>, <var>value</var>, and <var>timeout</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>mode</var> is either <code>"sync"</code> or <code>"async"</code>.</li><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_33"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>If <var>mode</var> is <code>"sync"</code>, then<ol><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>promiseCapability</var> be <emu-val>undefined</emu-val>.</li><li>If <var>mode</var> is <code>"async"</code>, then<ol><li>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_34"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</li></ol></li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_35"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_36"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>mode</var> is <code>"sync"</code>, then<ol><li>Return the String <code>"not-equal"</code>.</li></ol></li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_37"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>capability</var>.[[Resolve]], <emu-val>undefined</emu-val>, « <code>"not-equal"</code> »).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li>Let <var>waiterRecord</var> be a new <emu-xref href="#sec-getwaiterlist" id="_ref_38"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> { [[AgentSignifier]]: <var>W</var>, [[PromiseCapability]]: <var>promiseCapability</var>, [[Timeout]]: <var>t</var>, [[Result]]: <code>"ok"</code> }.</li><li>Perform <emu-xref aoid="AddWaiter" id="_ref_39"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>If <var>mode</var> is <code>"sync"</code>, then<ol><li>Perform <emu-xref aoid="Suspend" id="_ref_40"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_41"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>mode</var> is <code>"sync"</code>, then<ol><li>Return <var>waiterRecord</var>.[[Result]].</li></ol></li><li>Return <var>promiseCapability</var>.[[Promise]].
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1><span class="secnum">1.11</span>Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.wait</code> puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_42"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_43"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform <emu-xref aoid="EnterCriticalSection" id="_ref_44"><a href="#sec-entercriticalsection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_45"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Return the String <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li><del>Perform <emu-xref aoid="AddWaiter" id="_ref_46"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li><li><del>Let <var>notified</var> be <emu-xref aoid="Suspend" id="_ref_47"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, then</del><ol><li><del>Assert: <var>W</var> is not on the list of waiters in <var>WL</var>.</del></li></ol></li><li><del>Else,</del><ol><li><del>Perform <emu-xref aoid="RemoveWaiter" id="_ref_48"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li></ol></li><li><ins>Let <var>waiterRecord</var> be a new <emu-xref href="#sec-getwaiterlist" id="_ref_49"><a href="#sec-getwaiterlist">Waiter Record</a></emu-xref> { [[AgentSignifier]]: <var>W</var>, [[PromiseCapability]]: <emu-val>undefined</emu-val>, [[Timeout]]: <var>t</var>, [[Result]]: <code>"ok"</code> }.</ins></li><li><ins>Perform <emu-xref aoid="AddWaiter" id="_ref_50"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</ins></li><li><ins>Perform <emu-xref aoid="Suspend" id="_ref_51"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</ins></li><li>Perform <emu-xref aoid="LeaveCriticalSection" id="_ref_52"><a href="#sec-leavecriticalsection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, return the String <code>"ok"</code>.</del></li><li>Return <del>the String <code>"timed-out"</code></del><ins><var>waiterRecord</var>.[[Result]]</ins>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="atomics.waitasync">
    <h1><span class="secnum">1.12</span>Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new method.</ins></p>
    <p><code>Atomics.waitAsync</code> returns a Promise that is resolved when the calling agent is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Return <emu-xref aoid="DoWait" id="_ref_53"><a href="#sec-dowait">DoWait</a></emu-xref>(<code>"async"</code>, <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var>).
    </li></ol></emu-alg>
  </emu-clause>

</emu-clause>
</div></body>