<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Atomics.waitAsync","titleHTML":"Atomics.waitAsync","number":"","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync"},{"type":"op","aoid":"HostResolveInAgent","refId":"sec-hostresolveinagent","location":"","referencingIds":[],"key":"HostResolveInAgent"},{"type":"clause","id":"sec-hostresolveinagent","aoid":"HostResolveInAgent","title":"HostResolveInAgent ( W, promiseCapability, resolution)","titleHTML":"HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)","number":"1.1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_12"],"key":"HostResolveInAgent ( W, promiseCapability, resolution)"},{"type":"term","term":"WaiterList","refId":"sec-getwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"WaiterList"},{"type":"term","term":"WaiterList","refId":"sec-getwaiterlist","referencingIds":[],"namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","key":"WaiterList"},{"type":"clause","id":"sec-getwaiterlist","aoid":null,"title":"GetWaiterList ( block, i )","titleHTML":"GetWaiterList ( <var>block</var>, <var>i</var> )","number":"1.2","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_0","_ref_1","_ref_4","_ref_5","_ref_7","_ref_8","_ref_11"],"key":"GetWaiterList ( block, i )"},{"type":"op","aoid":"TriggerTimeout","refId":"sec-triggertimeout","location":"","referencingIds":[],"key":"TriggerTimeout"},{"type":"clause","id":"sec-triggertimeout","aoid":"TriggerTimeout","title":"TriggerTimeout( WL, waiterRecord )","titleHTML":"TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )","number":"1.3","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_6"],"key":"TriggerTimeout( WL, waiterRecord )"},{"type":"op","aoid":"AddWaiter","refId":"sec-addwaiter","location":"","referencingIds":[],"key":"AddWaiter"},{"type":"clause","id":"sec-addwaiter","aoid":"AddWaiter","title":"AddWaiter ( WL,  WwaiterRecord )","titleHTML":"AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.4","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_15","_ref_18","_ref_24"],"key":"AddWaiter ( WL,  WwaiterRecord )"},{"type":"op","aoid":"RemoveWaiter","refId":"sec-removewaiter","location":"","referencingIds":[],"key":"RemoveWaiter"},{"type":"clause","id":"sec-removewaiter","aoid":"RemoveWaiter","title":"RemoveWaiter ( WL,  WwaiterRecord )","titleHTML":"RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.5","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_2","_ref_17"],"key":"RemoveWaiter ( WL,  WwaiterRecord )"},{"type":"op","aoid":"Suspend","refId":"sec-suspend","location":"","referencingIds":[],"key":"Suspend"},{"type":"clause","id":"sec-suspend","aoid":"Suspend","title":"Suspend ( WL, W, timeout )","titleHTML":"Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )","number":"1.6","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_16","_ref_19"],"key":"Suspend ( WL, W, timeout )"},{"type":"op","aoid":"NotifyWaiter","refId":"sec-notifywaiter","location":"","referencingIds":[],"key":"NotifyWaiter"},{"type":"clause","id":"sec-notifywaiter","aoid":"NotifyWaiter","title":"NotifyWaiter ( WL,  WwaiterRecord )","titleHTML":"NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )","number":"1.7","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":["_ref_3","_ref_9","_ref_10"],"key":"NotifyWaiter ( WL,  WwaiterRecord )"},{"type":"clause","id":"sec-atomics.wait","aoid":null,"title":"Atomics.wait ( typedArray, index, value, timeout )","titleHTML":"Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.8","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.wait ( typedArray, index, value, timeout )"},{"type":"clause","id":"atomics.waitasync","aoid":null,"title":"Atomics.waitAsync ( typedArray, index, value, timeout )","titleHTML":"Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.9","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Atomics.waitAsync ( typedArray, index, value, timeout )"},{"type":"clause","id":"sec-semantics","aoid":null,"title":"Semantics","titleHTML":"Semantics","number":"1","namespace":"https://github.com/tc39/proposal-atomics-wait-async","location":"","referencingIds":[],"key":"Semantics"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Atomics.waitAsync">Atomics.waitAsync</a></li><li><span class="item-toggle">◢</span><a href="#sec-semantics" title="Semantics"><span class="secnum">1</span> Semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-hostresolveinagent" title="HostResolveInAgent ( W, promiseCapability, resolution)"><span class="secnum">1.1</span> HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</a></li><li><span class="item-toggle-none"></span><a href="#sec-getwaiterlist" title="GetWaiterList ( block, i )"><span class="secnum">1.2</span> GetWaiterList ( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-triggertimeout" title="TriggerTimeout( WL, waiterRecord )"><span class="secnum">1.3</span> TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-addwaiter" title="AddWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.4</span> AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-removewaiter" title="RemoveWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.5</span> RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-suspend" title="Suspend ( WL, W, timeout )"><span class="secnum">1.6</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-notifywaiter" title="NotifyWaiter ( WL,  WwaiterRecord )"><span class="secnum">1.7</span> NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.wait" title="Atomics.wait ( typedArray, index, value, timeout )"><span class="secnum">1.8</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#atomics.waitasync" title="Atomics.waitAsync ( typedArray, index, value, timeout )"><span class="secnum">1.9</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li></ol></li></ol></div></div><div id="spec-container"><h1 class="version first">Stage 2 Draft / September 27, 2019</h1>
<emu-intro id="intro">
  <h1>Atomics.waitAsync</h1>
  <p>We provide a new API, <code>Atomics.waitAsync</code>, that an agent can use to wait on a shared memory location (to later be awoken by some agent calling Atomics.notify on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1><span class="secnum">1</span>Semantics</h1>

  <emu-clause id="sec-hostresolveinagent" aoid="HostResolveInAgent">
    <h1><span class="secnum">1.1</span>HostResolveInAgent ( <var>W</var>, <var>promiseCapability</var>, <var>resolution</var>)</h1>
    <p><ins>This is a new section.</ins></p>
    <p>HostResolveInAgent is an implementation-defined abstract operation that takes three arguments, an agent signifier <var>W</var>, a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>promiseCapability</var>, and a value <var>resolution</var>. The host's responsibility is to resolve the <var>promiseCapability</var> in the agent signified by <var>W</var> with <var>resolution</var> in finite time. The host may delay resolving the <var>promiseCapability</var> in <var>W</var>, e.g. for resource management reasons, but the promise must eventually be resolved.</p>
  </emu-clause>

  <emu-clause id="sec-getwaiterlist">
    <h1><span class="secnum">1.2</span>GetWaiterList ( <var>block</var>, <var>i</var> )</h1>
    <p>A  <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>.</p>
    <p>A  <dfn>WaiterList</dfn> is a semantic object that contains an ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>  <del>of those agents that are</del><ins>of Records of the agent signifier, promise capability (possibly <emu-val>undefined</emu-val>), and timeout of the agent that is</ins> waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>. A WaiterList object also optionally contains a Synchronize event denoting the previous leaving of its critical section.</p>
    <p><ins>There can be multiple entries in a WaiterList with the same agent signifier.</ins></p>
    <p>The agent cluster has a store of WaiterList objects; the store is indexed by (<var>block</var>, <var>i</var>). WaiterLists are agent-independent: a lookup in the store of WaiterLists by (<var>block</var>, <var>i</var>) will result in the same WaiterList object in any agent in the agent cluster.</p>
    <p>Operations on a WaiterList—adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, setting and retrieving the Synchronize event—may only be performed by agents that have entered the WaiterList's critical section.</p>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>Conceptually, agents that call either <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> are appended to WaiterList. If the call was to <code>Atomics.wait</code> in an agent A, a record with an <emu-val>undefined</emu-val> promise capability is inserted to be immediately preceding the first element whose agent signifier is A. If the call was to <code>Atomics.waitAsync</code>, the pair of the result PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> and A (<var>capability</var>, A) is appended.</p>
      <p>This enables two design goals:</p>
      <ol>
        <li>Waiting agents are notified in FIFO order for fairness.</li>
        <li>Asynchronous waits in one agent are notified in FIFO order, while synchronous waits are notified before any asynchronous wait. This is because resolving the Promise result of a call to <code>Atomics.waitAsync</code> does no meaningful computation if the agent is in a blocking wait.</li>
      </ol>
    </div></emu-note>
    <p>The abstract operation GetWaiterList takes two arguments, a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> and a nonnegative integer <var>i</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var> + 3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <emu-xref href="#sec-getwaiterlist" id="_ref_0"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> that is referenced by the pair (<var>block</var>, <var>i</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-triggertimeout" aoid="TriggerTimeout">
    <h1><span class="secnum">1.3</span>TriggerTimeout( <var>WL</var>, <var>waiterRecord</var> )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation TriggerTimeout takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_1"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>waiterRecord</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>waiterRecord</var>.[[Timeout]] is finite.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>If <var>waiterRecord</var> is on the list of waiters in <var>WL</var>, then<ol><li>Set <var>waiterRecord</var>.[[Result]] to <code>"timed-out"</code>.</li><li>Perform <emu-xref aoid="RemoveWaiter" id="_ref_2"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_3"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-addwaiter" aoid="AddWaiter">
    <h1><span class="secnum">1.4</span>AddWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation AddWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_4"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><del>Assert: <var>W</var> is not on the list of waiters in any <emu-xref href="#sec-getwaiterlist" id="_ref_5"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref>.</del></li><li><ins>Let <var>inserted</var> be <emu-val>false</emu-val>.</ins></li><li><ins>If <var>waiterRecord</var>.[[PromiseCapability]] is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>Assert: There is no record in <var>WL</var> whose [[AgentSignifier]] field is <var>waiterRecord</var>.[[AgentSignifier]].</ins></li><li><ins>For each element <var>wr</var> in <var>WL</var>, do</ins><ol><li><ins>If <var>wr</var>.[[AgentSignifier]] is <var>waiterRecord</var>.[[AgentSignifier]], then</ins><ol><li><ins>Insert <var>waiterRecord</var> to immediately precede <var>wr</var>.</ins></li><li><ins>Set <var>inserted</var> to <emu-val>true</emu-val>.</ins></li></ol></li></ol></li></ol></li><li><ins>If <var>inserted</var> is <emu-val>false</emu-val>, then</ins><ol><li><ins>Append <var>waiterRecord</var> as the last element of <var>WL</var>.</ins></li></ol></li><li><ins>If <var>waiterRecord</var>.[[Timeout]] is finite, then in parallel,</ins><ol><li>Wait <var>waiterRecord</var>.[[Timeout]] milliseconds.</li><li>Perform <emu-xref aoid="TriggerTimeout" id="_ref_6"><a href="#sec-triggertimeout">TriggerTimeout</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).
    </li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
    <h1><span class="secnum">1.5</span>RemoveWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation RemoveWaiter takes two arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_7"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <del><var>W</var></del><ins><var>waiterRecord</var></ins> is on the list of waiters in <var>WL</var>.</li><li>Remove <del><var>W</var></del><ins><var>waiterRecord</var></ins> from the list of waiters in <var>WL</var>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a <var>timeout</var> argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1><span class="secnum">1.6</span>Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</h1>
    <p>The abstract operation Suspend takes  <del>three</del><ins>two</ins> arguments, a <emu-xref href="#sec-getwaiterlist" id="_ref_8"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var><del>,</del><ins>and</ins> an agent signifier <var>W</var><del>, and a nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var></del>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to AgentSignifier().</li><li>Assert: <del><var>W</var> is on the list of waiters.</del><ins>There is a record</ins> in <var>WL</var> <ins>whose [[AgentSignifier]] field is <var>W</var> and whose [[PromiseCapability]] field is <emu-val>undefined</emu-val>.</ins></li><li>Assert: AgentCanSuspend() is <emu-val>true</emu-val>.</li><li>Perform LeaveCriticalSection(<var>WL</var>) and suspend <var>W</var><del> for up to <var>timeout</var> milliseconds</del>, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_9"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>, ...), and not for any other reasons at all.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li><del>If <var>W</var> was notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_10"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), return <emu-val>true</emu-val>.</del></li><li><del>Return <emu-val>false</emu-val>.</del>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1><span class="secnum">1.7</span>NotifyWaiter ( <var>WL</var>,  <del><var>W</var></del><ins><var>waiterRecord</var></ins> )</h1>
    <p>The abstract operation NotifyWaiter takes two arguments,
      a <emu-xref href="#sec-getwaiterlist" id="_ref_11"><a href="#sec-getwaiterlist">WaiterList</a></emu-xref> <var>WL</var> and  <del>an agent signifier <var>W</var></del><ins>a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>waiterRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><del>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</del></li><li><ins>Assert: <var>waiterRecord</var>.[[Result]] is either the String <code>"ok"</code> or the String <code>"timed-out"</code>.</ins></li><li><del>Notify the agent <var>W</var>.</del></li><li><ins>If <var>waiterRecord</var>.[[PromiseCapability]] is <emu-val>undefined</emu-val>, then</ins><ol><li><ins>NOTE: An <emu-val>undefined</emu-val> promise capability denotes a blocking wait.</ins></li><li><ins>Notify the agent <var>waiterRecord</var>.[[AgentSignifier]].</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Perform <emu-xref aoid="HostResolveInAgent" id="_ref_12"><a href="#sec-hostresolveinagent">HostResolveInAgent</a></emu-xref>(<var>W</var>, <var>waiterRecord</var>.[[PromiseCapability]], <var>waiterRecord</var>.[[Result]])</ins></li><li><ins>NOTE: An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</ins>
    </li></ol></li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>The embedding may delay notifying  <del><var>W</var></del><ins>the agent whose signifier is <var>waiter</var>.[[AgentSignifier]]</ins>, e.g. for resource management reasons, but  <del><var>W</var></del><ins>that agent</ins> must eventually be notified in order to guarantee forward progress.</p>
    </div></emu-note>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1><span class="secnum">1.8</span>Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.wait</code> puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_13"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_14"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return the String <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li><del>Perform <emu-xref aoid="AddWaiter" id="_ref_15"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li><li><del>Let <var>notified</var> be <emu-xref aoid="Suspend" id="_ref_16"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, then</del><ol><li><del>Assert: <var>W</var> is not on the list of waiters in <var>WL</var>.</del></li></ol></li><li><del>Else,</del><ol><li><del>Perform <emu-xref aoid="RemoveWaiter" id="_ref_17"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li></ol></li><li><ins>Let <var>waiterRecord</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[AgentSignifier]]: <var>W</var>, [[PromiseCapability]]: <emu-val>undefined</emu-val>, [[Timeout]]: <var>t</var>, [[Result]]: <code>"ok"</code> }.</ins></li><li><ins>Perform <emu-xref aoid="AddWaiter" id="_ref_18"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</ins></li><li><ins>Perform <emu-xref aoid="Suspend" id="_ref_19"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</ins></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, return the String <code>"ok"</code>.</del></li><li>Return <del>the String <code>"timed-out"</code></del><ins><var>waiterRecord</var>.[[Result]]</ins>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="atomics.waitasync">
    <h1><span class="secnum">1.9</span>Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new method.</ins></p>
    <p><code>Atomics.waitAsync</code> returns a Promise that is resolved when the calling agent is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_20"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_21"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_22"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_23"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>capability</var>.[[Resolve]], <emu-val>undefined</emu-val>, « <code>"not-equal"</code> »).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li>Let <var>waiterRecord</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[AgentSignifier]]: <var>W</var>, [[PromiseCapability]]: <var>promiseCapability</var>, [[Timeout]]: <var>t</var>, [[Result]]: <code>"ok"</code> }.</li><li>Perform <emu-xref aoid="AddWaiter" id="_ref_24"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>waiterRecord</var>).</li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].
    </li></ol></emu-alg>
  </emu-clause>

</emu-clause>
</div></body>