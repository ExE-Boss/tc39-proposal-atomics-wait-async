<!doctype html>
<head><meta charset="utf-8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Atomics.waitAsync","titleHTML":"Atomics.waitAsync","number":"","namespace":"<no location>","location":"","referencingIds":[],"key":"Atomics.waitAsync"},{"type":"term","term":"ClusterWaiterList","refId":"sec-semantics","referencingIds":[],"namespace":"<no location>","location":"","key":"ClusterWaiterList"},{"type":"term","term":"AgentWaitList","refId":"sec-semantics","referencingIds":[],"namespace":"<no location>","location":"","key":"AgentWaitList"},{"type":"term","term":"ClusterWaiterList","refId":"sec-clusterwaiterlist","referencingIds":[],"namespace":"<no location>","location":"","key":"ClusterWaiterList"},{"type":"term","term":"alarm set","refId":"sec-clusterwaiterlist","referencingIds":[],"namespace":"<no location>","location":"","key":"alarm set"},{"type":"clause","id":"sec-clusterwaiterlist","aoid":null,"title":"GetClusterWaiterList ( block, i )","titleHTML":"Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )","number":"1.1","namespace":"<no location>","location":"","referencingIds":["_ref_16","_ref_17","_ref_18","_ref_19","_ref_22","_ref_23"],"key":"GetClusterWaiterList ( block, i )"},{"type":"clause","id":"sec-alarm-functions","aoid":null,"title":"Alarm Functions","titleHTML":"Alarm Functions","number":"1.2","namespace":"<no location>","location":"","referencingIds":["_ref_0","_ref_1"],"key":"Alarm Functions"},{"type":"op","aoid":"AddWaiter","refId":"sec-addwaiter","location":"","referencingIds":[],"key":"AddWaiter"},{"type":"clause","id":"sec-addwaiter","aoid":"AddWaiter","title":"AddWaiter ( WL, W, asyncRecord )","titleHTML":"AddWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )","number":"1.3","namespace":"<no location>","location":"","referencingIds":["_ref_28","_ref_33","_ref_42"],"key":"AddWaiter ( WL, W, asyncRecord )"},{"type":"op","aoid":"RemoveWaiter","refId":"sec-removewaiter","location":"","referencingIds":[],"key":"RemoveWaiter"},{"type":"clause","id":"sec-removewaiter","aoid":"RemoveWaiter","title":"RemoveWaiter ( WL, W, asyncRecord )","titleHTML":"RemoveWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )","number":"1.4","namespace":"<no location>","location":"","referencingIds":["_ref_9","_ref_30"],"key":"RemoveWaiter ( WL, W, asyncRecord )"},{"type":"op","aoid":"RemoveWaiters","refId":"sec-removewaiters","location":"","referencingIds":[],"key":"RemoveWaiters"},{"type":"clause","id":"sec-removewaiters","aoid":"RemoveWaiters","title":"RemoveWaiters ( WL, c )","titleHTML":"RemoveWaiters ( <var>WL</var>, <var>c</var> )","number":"1.5","namespace":"<no location>","location":"","referencingIds":["_ref_45"],"key":"RemoveWaiters ( WL, c )"},{"type":"op","aoid":"Suspend","refId":"sec-suspend","location":"","referencingIds":[],"key":"Suspend"},{"type":"clause","id":"sec-suspend","aoid":"Suspend","title":"Suspend ( WL, W, timeout )","titleHTML":"Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )","number":"1.6","namespace":"<no location>","location":"","referencingIds":["_ref_29","_ref_34"],"key":"Suspend ( WL, W, timeout )"},{"type":"op","aoid":"NotifyWaiter","refId":"sec-notifywaiter","location":"","referencingIds":[],"key":"NotifyWaiter"},{"type":"clause","id":"sec-notifywaiter","aoid":"NotifyWaiter","title":"NotifyWaiter ( WL, W, asyncRecord, value )","titleHTML":"NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var>, <var>value</var></ins> )","number":"1.7","namespace":"<no location>","location":"","referencingIds":["_ref_10","_ref_11","_ref_12","_ref_46"],"key":"NotifyWaiter ( WL, W, asyncRecord, value )"},{"type":"op","aoid":"AddAlarm","refId":"sec-addalarm","location":"","referencingIds":[],"key":"AddAlarm"},{"type":"clause","id":"sec-addalarm","aoid":"AddAlarm","title":"AddAlarm( WL, alarmFn, timeout )","titleHTML":"AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )","number":"1.8","namespace":"<no location>","location":"","referencingIds":["_ref_24","_ref_32","_ref_41"],"key":"AddAlarm( WL, alarmFn, timeout )"},{"type":"op","aoid":"CancelAlarm","refId":"sec-cancelalarm","location":"","referencingIds":[],"key":"CancelAlarm"},{"type":"clause","id":"sec-cancelalarm","aoid":"CancelAlarm","title":"CancelAlarm( WL, alarm )","titleHTML":"CancelAlarm( <var>WL</var>, <var>alarm</var> )","number":"1.9","namespace":"<no location>","location":"","referencingIds":["_ref_14","_ref_35"],"key":"CancelAlarm( WL, alarm )"},{"type":"clause","id":"sec-atomics.wait","aoid":null,"title":"Atomics.wait ( typedArray, index, value, timeout )","titleHTML":"Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.10","namespace":"<no location>","location":"","referencingIds":[],"key":"Atomics.wait ( typedArray, index, value, timeout )"},{"type":"clause","id":"atomics.waitasync","aoid":null,"title":"Atomics.waitAsync ( typedArray, index, value, timeout )","titleHTML":"Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )","number":"1.11","namespace":"<no location>","location":"","referencingIds":[],"key":"Atomics.waitAsync ( typedArray, index, value, timeout )"},{"type":"clause","id":"sec-atomics.notify","aoid":null,"title":"Atomics.notify ( typedArray, index, count )","titleHTML":"Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )","number":"1.12","namespace":"<no location>","location":"","referencingIds":[],"key":"Atomics.notify ( typedArray, index, count )"},{"type":"clause","id":"sec-semantics","aoid":null,"title":"Semantics","titleHTML":"Semantics","number":"1","namespace":"<no location>","location":"","referencingIds":["_ref_4","_ref_5","_ref_6","_ref_8","_ref_15","_ref_21"],"key":"Semantics"},{"type":"clause","id":"sec-copyright-and-software-license","aoid":null,"title":"Copyright & Software License","titleHTML":"Copyright &amp; Software License","number":"A","namespace":"<no location>","location":"","referencingIds":[],"key":"Copyright & Software License"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Atomics.waitAsync">Atomics.waitAsync</a></li><li><span class="item-toggle">◢</span><a href="#sec-semantics" title="Semantics"><span class="secnum">1</span> Semantics</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-clusterwaiterlist" title="GetClusterWaiterList ( block, i )"><span class="secnum">1.1</span> Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-alarm-functions" title="Alarm Functions"><span class="secnum">1.2</span> Alarm Functions</a></li><li><span class="item-toggle-none"></span><a href="#sec-addwaiter" title="AddWaiter ( WL, W, asyncRecord )"><span class="secnum">1.3</span> AddWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-removewaiter" title="RemoveWaiter ( WL, W, asyncRecord )"><span class="secnum">1.4</span> RemoveWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-removewaiters" title="RemoveWaiters ( WL, c )"><span class="secnum">1.5</span> RemoveWaiters ( <var>WL</var>, <var>c</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-suspend" title="Suspend ( WL, W, timeout )"><span class="secnum">1.6</span> Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-notifywaiter" title="NotifyWaiter ( WL, W, asyncRecord, value )"><span class="secnum">1.7</span> NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var>, <var>value</var></ins> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-addalarm" title="AddAlarm( WL, alarmFn, timeout )"><span class="secnum">1.8</span> AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-cancelalarm" title="CancelAlarm( WL, alarm )"><span class="secnum">1.9</span> CancelAlarm( <var>WL</var>, <var>alarm</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.wait" title="Atomics.wait ( typedArray, index, value, timeout )"><span class="secnum">1.10</span> Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#atomics.waitasync" title="Atomics.waitAsync ( typedArray, index, value, timeout )"><span class="secnum">1.11</span> Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#sec-atomics.notify" title="Atomics.notify ( typedArray, index, count )"><span class="secnum">1.12</span> Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-copyright-and-software-license" title="Copyright &amp; Software License"><span class="secnum">A</span> Copyright &amp; Software License</a></li></ol></div></div><div id="spec-container">
<emu-intro id="intro">
  <h1 class="first">Atomics.waitAsync</h1>
  <p>We provide a new API, <code>Atomics.waitAsync</code>, that an agent can use to wait on a shared memory location (to later be awoken by some agent calling Atomics.wake on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1><span class="secnum">1</span>Semantics</h1>
  <p>To support <code>Atomics.waitAsync</code>, the WaiterList semantic object is split into two semantic objects.</p>
  <p>A  <dfn>ClusterWaiterList</dfn> is a semantic object that contains an ordered <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of agent signifiers of agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>. This list is agent-independent and, like the current WaiterList semantic object, is shared by all agents in an agent cluster.</p>
  <p>An  <dfn>AgentWaitList</dfn> is <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Records (that have a PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> and an alarm id) or <emu-val>null</emu-val>. Each <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> encapsulates the result of a call to <code>Atomics.waitAsync</code>, and <emu-val>null</emu-val> denotes a call to <code>Atomics.wait</code>. This list is per-agent.</p>
  <p>Conceptually, agents that call either <code>Atomics.wait</code> or <code>Atomics.waitAsync</code> are appended to ClusterWaiterList. If the call was to <code>Atomics.wait</code>, <emu-val>null</emu-val> is prepended to that agent's AgentWaitList. If the call was to <code>Atomics.waitAsync</code>, the result PromiseCapability <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> is appended to that agent's AgentWaitList.</p>
  <p>This enable two design goals:</p>
  <ol>
    <li>Waiting agents are notified in FIFO order for fairness.</li>
    <li>Asynchronous waits in one agent are notified in FIFO order, while synchronous waits are notified before any asynchronous wait. This is because resolving the Promise result of a call to <code>Atomics.waitAsync</code> does no meaningful computation if the agent is in a blocking wait.</li>
  </ol>

  <p>Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> is modified as follows.</p>
  <emu-table caption="Agent Record Fields"><figure><figcaption>Table 1: Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> Fields</figcaption>
    <table>
      <tbody>
        <tr>
          <th>Field Name</th>
          <th>Value</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>Boolean</td>
          <td>The default value computed for the  <em>isLittleEndian</em> parameter when it is needed by the algorithms <emu-xref aoid="GetValueFromBuffer" id="_ref_2"><a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer" id="_ref_3"><a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">SetValueInBuffer</a></emu-xref>. The choice is implementation-dependent and should be the alternative that is most efficient for the implementation.  Once the value has been observed it cannot change.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>Boolean</td>
          <td>Determines whether the agent can block or not.</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>Any globally-unique value</td>
          <td>Uniquely identifies the agent within its agent cluster.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>Boolean</td>
          <td><emu-val>true</emu-val> if atomic operations on one-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>Boolean</td>
          <td><emu-val>true</emu-val> if atomic operations on two-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>A candidate execution <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref></td>
          <td>See the memory model.</td>
        </tr>
      </tbody>
      <tbody><tr>
        <td><ins>[[WaitList]]</ins></td>
        <td><ins>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref></ins></td>
        <td><ins>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Records or <emu-val>null</emu-val> denoting calls to <code>Atomics.waitAsync</code> and <code>Atomics.wait</code>, respectively.</ins></td> 
    </tr></tbody></table>
  </figure></emu-table>

  <emu-clause id="sec-clusterwaiterlist">
    <h1><span class="secnum">1.1</span>Get<ins>Cluster</ins>WaiterList ( <var>block</var>, <var>i</var> )</h1>
    <p>A  <dfn><ins>Cluster</ins>WaiterList</dfn> is a semantic object that contains an ordered list of agent signifiers of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>.</p>
    <p><ins>There can be multiple entries in a <emu-xref href="#sec-semantics" id="_ref_4"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> with the same agent signifier.</ins></p>
    <p><ins>The <emu-xref href="#sec-semantics" id="_ref_5"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> has an attached  <dfn>alarm set</dfn>, a set of truthy values. This set is manipulated only when the agent manipulating it is in the critical section for the <emu-xref href="#sec-semantics" id="_ref_6"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref>.</ins></p>
    <p>The agent cluster has a store of  <ins>Cluster</ins>WaiterList objects; the store is indexed by (<var>block</var>, <var>i</var>). WaiterLists are agent-independent: a lookup in the store of  <ins>Cluster</ins>WaiterLists by (<var>block</var>, <var>i</var>) will result in the same  <ins>Cluster</ins>WaiterList object in any agent in the agent cluster.</p>
    <p>Operations on a  <ins>Cluster</ins>WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, adding and removing alarms -- may only be performed by agents that have entered the  <ins>Cluster</ins>WaiterList's critical section.</p>
    <p>The abstract operation <emu-xref aoid="Get" id="_ref_7"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList takes two arguments, a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <var>block</var> and a nonnegative integer <var>i</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: <var>block</var> is a Shared <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var> + 3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <ins>Cluster</ins>WaiterList that is referenced by the pair (<var>block</var>, <var>i</var>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-alarm-functions">
    <h1><span class="secnum">1.2</span>Alarm Functions</h1>
    <p><ins>This is a new section.</ins></p>
    <p>An alarm function is an anonymous built-in function that has [[WaiterList]], [[Waiter]], [[AsyncRecord]], and [[SyncResult]] internal slots.</p>
    <p>When an alarm function is called with no arguments, the following steps are taken:</p>
    <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href="#active-function-object"><a href="https://tc39.github.io/ecma262/#active-function-object">active function object</a></emu-xref>.</li><li>Assert: <var>F</var> has a [[WaiterList]] internal slot whose value is a <emu-xref href="#sec-semantics" id="_ref_8"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref>.</li><li>Assert: <var>F</var> has a [[Waiter]] internal slot whose value is an agent signifier.</li><li>Assert: <var>F</var> has a [[AsyncRecord]] internal slot whose value is either a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> or <emu-val>null</emu-val>.</li><li>If <var>F</var>.[[SyncResult]] is not <emu-val>null</emu-val>, then<ol><li>Set <var>F</var>.[[SyncResult]].[[Result]] to the String <code>"timed-out"</code>.</li><li>NOTE: [[SyncResult]] is used by <code>Atomics.wait</code> to communicate the result of the blocking wait.</li></ol></li><li>Perform <emu-xref aoid="RemoveWaiter" id="_ref_9"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>F</var>.[[AsyncRecord]]).</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_10"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>F</var>.[[AsyncRecord]], <code>"timed-out"</code>).
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-addwaiter" aoid="AddWaiter">
    <h1><span class="secnum">1.3</span>AddWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )</h1>
    <p>The abstract operation AddWaiter takes three arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var>  <del>and</del><ins>,</ins> an agent signifier <var>W</var>,  <ins>and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>asyncRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><ins>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</ins></li><li>Assert: <del><var>W</var> is not on the list of waiters in any WaiterList.</del><ins><var>asyncRecord</var> is not in <var>AR</var>.[[WaitList]].</ins></li><li>Add <var>W</var> to the end of the list of waiters in <var>WL</var>.</li><li><ins>If <var>asyncRecord</var> is <emu-val>null</emu-val>, then</ins><ol><li><ins>Insert <var>asyncRecord</var> to the beginning of <var>AR</var>.[[WaitList]].</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Insert <var>asyncRecord</var> to the end of <var>AR</var>.[[WaitList]].</ins>
    </li></ol></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
    <h1><span class="secnum">1.4</span>RemoveWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var></ins> )</h1>
    <p>The abstract operation RemoveWaiter takes three arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var>  <del>and</del><ins>,</ins> an agent signifier <var>W</var>,  <ins>and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>asyncRecord</var></ins>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li><ins>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</ins></li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li><ins>Assert: <var>asyncRecord</var> is in <var>AR</var>.[[WaitList]].</ins></li><li>Remove <var>W</var> from the list of waiters in <var>WL</var>.</li><li><ins>Remove <var>asyncRecord</var> from <var>AR</var>.[[WaitList]].</ins>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiters" aoid="RemoveWaiters">
    <h1><span class="secnum">1.5</span>RemoveWaiters ( <var>WL</var>, <var>c</var> )</h1>
    <p>The abstract operation RemoveWaiters takes two arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var> and nonnegative integer <var>c</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>L</var> be a new empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Let <var>S</var> be a reference to the list of waiters in <var>WL</var>.</li><li>Repeat, while <var>c</var> &gt; 0 and <var>S</var> is not an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>,<ol><li>Let <var>W</var> be the first waiter in <var>S</var>.</li><li><ins>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</ins></li><li><ins>Let <var>asyncRecord</var> be the first element in <var>AR</var>.[[WaitList]].</ins></li><li>Add <del><var>W</var></del><ins>a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[Signifier]]: <var>W</var>, [[AsyncRecord]]: <var>asyncRecord</var> }</ins> to the end of <var>L</var>.</li><li>Remove <var>W</var> from <var>S</var>.</li><li>Subtract 1 from <var>c</var>.</li></ol></li><li>Return <var>L</var>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a <var>timeout</var> argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1><span class="secnum">1.6</span>Suspend ( <var>WL</var>, <var>W</var><del>, <var>timeout</var></del> )</h1>
    <p>The abstract operation Suspend takes  <del>three</del><ins>two</ins> arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var><del>,</del><ins>and</ins> an agent signifier <var>W</var><del>, and a nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var></del>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to AgentSignifier().</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Assert: AgentCanSuspend() is <emu-val>true</emu-val>.</li><li>Perform LeaveCriticalSection(<var>WL</var>) and suspend <var>W</var> for up to <var>timeout</var> milliseconds, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_11"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, ...), and not for any other reasons at all.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li><del>If <var>W</var> was notified explicitly by another agent calling <emu-xref aoid="NotifyWaiter" id="_ref_12"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), return <emu-val>true</emu-val>.</del></li><li><del>Return <emu-val>false</emu-val>.</del>
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1><span class="secnum">1.7</span>NotifyWaiter ( <var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var>, <var>value</var></ins> )</h1>
    <p>The abstract operation NotifyWaiter takes  <del>two</del><ins>three</ins> arguments, a  <ins>Cluster</ins>WaiterList <var>WL</var>  <del>and<del><ins>,</ins> an agent signifier <var>W</var><ins>, and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> <var>asyncRecord</var></ins>. It performs the following steps:</del></del></p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Assert: <var>value</var> is either the String <code>"ok"</code> or the String <code>"timed-out"</code>.</li><li><ins>Let <var>AR</var> be the Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> whose [[Signifier]] field is <var>W</var>.</ins></li><li><ins>Assert: <var>asyncRecord</var> is in <var>AR</var>.[[WaitList]].</ins></li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the surrounding agent's Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</li><li>Let <var>eventsRecord</var> be the Agent Events <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().</li><li>Let <var>agentSynchronizesWith</var> be <var>eventsRecord</var>.[[AgentSynchronizesWith]].</li><li>Let <var>notifierEventList</var> be <var>eventsRecord</var>.[[EventList]].</li><li>Let <var>waiterEventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <var>W</var>.</li><li>Let <var>notifyEvent</var> and <var>waitEvent</var> be new Synchronize events.</li><li>Append <var>notifyEvent</var> to <var>notifierEventList</var>.</li><li>Append <var>waitEvent</var> to <var>waiterEventList</var>.</li><li>Append (<var>notifyEvent</var>, <var>waitEvent</var>) to <var>agentSynchronizesWith</var>.</li><li><del>Notify the agent <var>W</var>.</del><ins>If <var>asyncRecord</var> is <emu-val>null</emu-val>, then</ins><ol><li><ins>Notify the agent <var>W</var>.</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_13"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>asyncRecord</var>.[[PromiseCapability]].[[Resolve]], <emu-val>undefined</emu-val>, « <var>value</var> »)</ins></li><li><ins>If <var>asyncRecord</var>.[[Alarm]] is truthy, then</ins><ol><li><ins>Perform <emu-xref aoid="CancelAlarm" id="_ref_14"><a href="#sec-cancelalarm">CancelAlarm</a></emu-xref>(<var>WL</var>, <var>asyncRecord</var>.[[Alarm]]).</ins>
    </li></ol></li></ol></li></ol></emu-alg>
    <emu-note><span class="note">Note</span><div class="note-contents">
      <p>The embedding may delay notifying <var>W</var>, e.g. for resource management reasons, but <var>W</var> must eventually be notified in order to guarantee forward progress.</p>
    </div></emu-note>
  </emu-clause>

  <emu-clause id="sec-addalarm" aoid="AddAlarm">
    <h1><span class="secnum">1.8</span>AddAlarm( <var>WL</var>, <var>alarmFn</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation AddAlarm takes three arguments, a <emu-xref href="#sec-semantics" id="_ref_15"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> <var>WL</var>, a thunk <var>alarmFn</var>, and a nonnegative finite number <var>timeout</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>alarm</var> be a truthy value that is not in <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_16"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>Add <var>alarm</var> to <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_17"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>After <var>timeout</var> milliseconds has passed, perform the following actions concurrently:<ol><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>If <var>alarm</var> is in <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_18"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>, then<ol><li>Remove <var>alarm</var> from <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_19"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_20"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>alarmFn</var>, <emu-val>undefined</emu-val>, « »).</li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>NOTE: <var>alarmFn</var> is now dead.</li></ol></li><li>Return <var>alarm</var>.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-cancelalarm" aoid="CancelAlarm">
    <h1><span class="secnum">1.9</span>CancelAlarm( <var>WL</var>, <var>alarm</var> )</h1>
    <p><ins>This is a new abstraction operation.</ins></p>
    <p>The abstract operation CancelAlarm takes two arguments, a <emu-xref href="#sec-semantics" id="_ref_21"><a href="#sec-semantics">ClusterWaiterList</a></emu-xref> <var>WL</var>, and a truthy value <var>alarm</var>. It performs the following steps:</p>
    <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>alarm</var> is a truthy value.</li><li>If <var>alarm</var> is in <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_22"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>, then<ol><li>Remove <var>alarm</var> from <var>WL</var>'s <emu-xref href="#sec-clusterwaiterlist" id="_ref_23"><a href="#sec-clusterwaiterlist">alarm set</a></emu-xref>.</li></ol></li><li>NOTE: No alarm that subsequently triggers for alarm (in the concurrent thread referenced in <emu-xref aoid="AddAlarm" id="_ref_24"><a href="#sec-addalarm">AddAlarm</a></emu-xref>) will have any effect. The thunk associated with alarm is now dead and can be reclaimed; any scheduled timeout associated with alarm can be canceled.
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1><span class="secnum">1.10</span>Atomics.wait ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><code>Atomics.wait</code> puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_25"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_26"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="Get" id="_ref_27"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return the String <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li><del>Perform <emu-xref aoid="AddWaiter" id="_ref_28"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li><li><del>Let <var>notified</var> be <emu-xref aoid="Suspend" id="_ref_29"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</del></li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, then</del><ol><li><del>Assert: <var>W</var> is not on the list of waiters in <var>WL</var>.</del></li></ol></li><li><del>Else,</del><ol><li><del>Perform <emu-xref aoid="RemoveWaiter" id="_ref_30"><a href="#sec-removewaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</del></li></ol></li><li><ins>Let <var>syncResult</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> { [[Result]]: <code>"ok"</code> }.</ins></li><li><ins>Let <var>alarm</var> be <emu-val>false</emu-val>.</ins></li><li><ins>If <var>t</var> is finite, then</ins><ol><li><ins>Let <var>stepsAlarm</var> be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions" id="_ref_0"><a href="#sec-alarm-functions">1.2</a></emu-xref>).</ins></li><li><ins>Let <var>alarmFn</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_31"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(_stepsAlarm, « [[WaiterList]], [[Waiter]], [[AsyncRecord]], [[SyncResult]] »).</ins></li><li><ins>Set <var>alarmFn</var>.[[WaiterList]] to <var>WL</var>.</ins></li><li><ins>Set <var>alarmFn</var>.[[Waiter]] to <var>W</var>.</ins></li><li><ins>Set <var>alarmFn</var>.[[AsyncRecord]] to <emu-val>null</emu-val>.</ins></li><li><ins>Set <var>alarmFn</var>.[[SyncResult]] to <var>syncResult</var>.</ins></li><li><ins>Set <var>alarm</var> to <emu-xref aoid="AddAlarm" id="_ref_32"><a href="#sec-addalarm">AddAlarm</a></emu-xref>(<var>WL</var>, <var>alarmFn</var>, <var>t</var>).</ins></li></ol></li><li><ins>Perform <emu-xref aoid="AddWaiter" id="_ref_33"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, *null).</ins></li><li><ins>Perform <emu-xref aoid="Suspend" id="_ref_34"><a href="#sec-suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>).</ins></li><li><ins>If <var>syncResult</var>.[[Result]] is <code>"ok"</code>, then</ins><ol><li><ins>Perform <emu-xref aoid="CancelAlarm" id="_ref_35"><a href="#sec-cancelalarm">CancelAlarm</a></emu-xref>(<var>WL</var>, <var>alarm</var>).</ins></li></ol></li><li>Assert: The [[WaitList]] field of <var>W</var>'s Agent <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> does not contain <emu-val>null</emu-val>.</li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li><del>If <var>notified</var> is <emu-val>true</emu-val>, return the String <code>"ok"</code>.</del></li><li>Return <del>the String <code>"timed-out"</code></del><ins><var>syncResult</var>.[[Result]]<!-- ns-->.
    </ins></li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="atomics.waitasync">
    <h1><span class="secnum">1.11</span>Atomics.waitAsync ( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</h1>
    <p><ins>This is a new method.</ins></p>
    <p><code>Atomics.waitAsync</code> returns a Promise that is resolved when the calling agent is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ?&nbsp;<emu-xref aoid="ToInt32" id="_ref_36"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>Let <var>q</var> be ?&nbsp;<emu-xref aoid="ToNumber" id="_ref_37"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val>, let <var>t</var> be <emu-val>+∞</emu-val>, else let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>q</var>, 0).</li><li>Let <var>B</var> be AgentCanSuspend().</li><li>If <var>B</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be GetClusterWaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>promiseCapability</var> be !&nbsp;<emu-xref aoid="NewPromiseCapability" id="_ref_38"><a href="https://tc39.github.io/ecma262/#sec-newpromisecapability">NewPromiseCapability</a></emu-xref>(<emu-xref href="#sec-promise-constructor"><a href="https://tc39.github.io/ecma262/#sec-promise-constructor">%Promise%</a></emu-xref>).</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>w</var> be !&nbsp;AtomicLoad(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> is not equal to <var>w</var>, then<ol><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Perform !&nbsp;<emu-xref aoid="Call" id="_ref_39"><a href="https://tc39.github.io/ecma262/#sec-call">Call</a></emu-xref>(<var>capability</var>.[[Resolve]], <emu-val>undefined</emu-val>, « <code>"not-equal"</code> »).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></li><li>Let <var>W</var> be AgentSignifier().</li><li>Let <var>alarm</var> be <emu-val>false</emu-val>.</li><li>Let <var>asyncRecord</var> be { [[PromiseCapability]]: <var>promiseCapability</var>, [[Alarm]]: <var>alarm</var> }.</li><li>Let <var>t</var> is finite, then<ol><li>Let <var>stepsAlarm</var> be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions" id="_ref_1"><a href="#sec-alarm-functions">1.2</a></emu-xref>).</li><li>Let <var>alarmFn</var> be <emu-xref aoid="CreateBuiltinFunction" id="_ref_40"><a href="https://tc39.github.io/ecma262/#sec-createbuiltinfunction">CreateBuiltinFunction</a></emu-xref>(_stepsAlarm, « [[WaiterList]], [[Waiter]], [[AsyncRecord]], [[SyncResult]] »).</li><li>Set <var>alarmFn</var>.[[WaiterList]] to <var>WL</var>.</li><li>Set <var>alarmFn</var>.[[Waiter]] to <var>W</var>.</li><li>Set <var>alarmFn</var>.[[AsyncRecord]] to <var>asyncRecord</var>.</li><li>Set <var>alarmFn</var>.[[SyncResult]] to <emu-val>null</emu-val>.</li><li>Set <var>alarm</var> to <emu-xref aoid="AddAlarm" id="_ref_41"><a href="#sec-addalarm">AddAlarm</a></emu-xref>(<var>WL</var>, <var>alarmFn</var>, <var>t</var>).</li><li>Set <var>asyncRecord</var>.[[Alarm]] to <var>alarm</var>.</li></ol></li><li>Perform <emu-xref aoid="AddWaiter" id="_ref_42"><a href="#sec-addwaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>asyncRecord</var>).</li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].
    </li></ol></emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.notify">
    <h1><span class="secnum">1.12</span>Atomics.notify ( <var>typedArray</var>, <var>index</var>, <var>count</var> )</h1>
    <p><code>Atomics.notify</code> notifies some agents that are sleeping in the wait queue.  The following steps are taken:</p>
    <emu-alg><ol><li>Let <var>buffer</var> be ?&nbsp;ValidateSharedIntegerTypedArray(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ?&nbsp;ValidateAtomicAccess(<var>typedArray</var>, <var>index</var>).</li><li>If <var>count</var> is <emu-val>undefined</emu-val>, let <var>c</var> be <emu-val>+∞</emu-val>.</li><li>Else,<ol><li>Let <var>intCount</var> be ?&nbsp;<emu-xref aoid="ToInteger" id="_ref_43"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>count</var>).</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>intCount</var>, 0).</li></ol></li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="Get" id="_ref_44"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref><ins>Cluster</ins>WaiterList(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>n</var> be 0.</li><li>Perform EnterCriticalSection(<var>WL</var>).</li><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters" id="_ref_45"><a href="#sec-removewaiters">RemoveWaiters</a></emu-xref>(<var>WL</var>, <var>c</var>).</li><li>Repeat, while <var>S</var> is not an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>,<ol><li>Let <var>W</var> be the <del>first agent</del><ins>the [[Signifier]] field of the first element</ins> in <var>S</var>.</li><li><ins>Let <var>asyncRecord</var> be the [[AsyncRecord]] field of the first element of <var>S</var>.</ins></li><li>Remove <del><var>W</var></del><ins>the first element</ins> from the front of <var>S</var>.</li><li>Perform <emu-xref aoid="NotifyWaiter" id="_ref_46"><a href="#sec-notifywaiter">NotifyWaiter</a></emu-xref>(<var>WL</var>, <var>W</var><ins>, <var>asyncRecord</var>, <code>"ok"</code></ins>).</li><li>Add 1 to <var>n</var>.</li></ol></li><li>Perform LeaveCriticalSection(<var>WL</var>).</li><li>Return <var>n</var>.
    </li></ol></emu-alg>
  </emu-clause>

</emu-clause><emu-annex id="sec-copyright-and-software-license">
      <h1><span class="secnum">A</span>Copyright &amp; Software License</h1>
      
      <h2>Copyright Notice</h2>
      <p>© 2019 Lars Hansen, Shu-yu Guo, Ecma International</p>

      <h2>Software License</h2>
      <p>All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT https://ecma-international.org/memento/codeofconduct.htm FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ol>
  <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
  <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
  <li>Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>

<p>THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </emu-annex>
</div></body>